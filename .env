#! /bin/bash
echo "[DBUG] sourcing .env"
##
## General config
##
#echo "reading general config..."
export K8S_TYPE="${2:-$K8S_TYPE}"
export K8S_CLUSTER_KORIFI="${1:-$K8S_CLUSTER_KORIFI}"
if [[ -z "$K8S_CLUSTER_KORIFI" ]]; then
  echo "K8S_CLUSTER_KORIFI is empty! This must be set as env variable or provided as first parameter!"
  return 1
fi

echo "
============================================================
Using following variables:
- K8S_TYPE:		$K8S_TYPE
- K8S_CLUSTER_KORIFI:	$K8S_CLUSTER_KORIFI
============================================================
"


export GO_VERSION=1.24.2
export K8S_VERSION="1.30.0"
export CERT_MANAGER_VERSION="1.17.2"
export KPACK_VERSION="0.17.0"

export CONTOUR_VERSION="1.26.3"	# required version for Korifi 0.15.1
export ENVOY_VERSION="1.29.0"	# required version for Korifi 0.15.1
export KORIFI_VERSION="0.15.1"

export BASE_DOMAIN="${K8S_CLUSTER_KORIFI}.fake"
export CF_API_DOMAIN="api.${BASE_DOMAIN}"
export CF_APPS_DOMAIN="apps.${BASE_DOMAIN}"
export CF_HTTP_PORT=80
export CF_HTTPS_PORT=443

export ADMIN_USERNAME="cf-admin@${K8S_CLUSTER_KORIFI}"
export ROOT_NAMESPACE="cf"
export KORIFI_NAMESPACE="korifi"
export GATEWAY_CLASS_NAME="contour"

export CERT_PATH="$scriptpath/tmp"
mkdir -p "$CERT_PATH"

# docker images registry config (dummies are sufficient for KIND clusters)
export DOCKER_REGISTRY_ENV_FILE="$scriptpath/.env.docker-registry"
# default values
export DOCKER_REGISTRY_SERVER=""                # ghcr.io"
export DOCKER_REGISTRY_USERNAME=""		# rogerniesten
export DOCKER_REGISTRY_PASSWORD=""		# Must be provided via commandline or environment variable
export DOCKER_REGISTRY_CONTAINER_REPOSITORY=""  # ghcr.io/rogerniesten/korifi
export DOCKER_REGISTRY_BUILDER_REPOSITORY=""    # ghcr.io/rogerniesten/korifi/kpack-builder"
# Now read pre-saved values from env file (if exisiting)
test -f "$DOCKER_REGISTRY_ENV_FILE" && . "$DOCKER_REGISTRY_ENV_FILE"
#echo "...done"


##
## Container Images to be used
## ---------------------------
##

## Make sure to use the format <registry>/<repository>/<image-name>:<tag>
## And use the ORIGINAL repository (not your local repository if applicable)! (This will be prepended later in the script if applicable)

export DOCKER_IMAGE_REGISTRY=index.docker.io
export GHCR_IMAGE_REGISTRY=ghcr.io
export QUAY_IMAGE_REGISTRY=quay.io
export K8S_IMAGE_REGISTRY=registry.k8s.io

# Korifi images (by default from index.docker.ioi
export KORIFI_HELM_HOOKSIMAGE="${DOCKER_IMAGE_REGISTRY}/alpine/k8s:1.25.2"
export KORIFI_API_IMAGE="${DOCKER_IMAGE_REGISTRY}/cloudfoundry/korifi-api:${KORIFI_VERSION}"
export KORIFI_CONTROLLERS_IMAGE="${DOCKER_IMAGE_REGISTRY}/cloudfoundry/korifi-controllers:${KORIFI_VERSION}"
export KORIFI_JOBSTASKRUNNER_IMAGE="${DOCKER_IMAGE_REGISTRY}/cloudfoundry/korifi-job-task-runner:${KORIFI_VERSION}"
export KORIFI_KPACKBUILDER_IMAGE="${DOCKER_IMAGE_REGISTRY}/cloudfoundry/korifi-kpack-image-builder:${KORIFI_VERSION}"
export KORIFI_STATEFULSETRUNNER_IMAGE="${DOCKER_IMAGE_REGISTRY}/cloudfoundry/korifi-statefulset-runner:${KORIFI_VERSION}"
# kpack images
export KPACK_CONTROLLER_IMAGE="${GHCR_IMAGE_REGISTRY}/buildpacks-community/kpack/controller:${KPACK_VERSION}"
export KPACK_WEBHOOK_IMAGE="${GHCR_IMAGE_REGISTRY}/buildpacks-community/kpack/webhook:${KPACK_VERSION}"
export KPACK_BUILD_INIT_IMAGE="${GHCR_IMAGE_REGISTRY}/buildpacks-community/kpack/build-init:${KPACK_VERSION}"
export KPACK_BUILD_WAITER_IMAGE="${GHCR_IMAGE_REGISTRY}/buildpacks-community/kpack/build-waiter:${KPACK_VERSION}"
export KPACK_REBASE_IMAGE="${GHCR_IMAGE_REGISTRY}/buildpacks-community/kpack/rebase:${KPACK_VERSION}"
export KPACK_COMPLETION_IMAGE="${GHCR_IMAGE_REGISTRY}/buildpacks-community/kpack/completion:${KPACK_VERSION}"
export KPACK_LIVECYCLE_IMAGE="${GHCR_IMAGE_REGISTRY}/buildpacks-community/kpack/lifecycle:${KPACK_VERSION}"

# contour images (from ghcr.io)
export CONTOUR_CONTOUR_IMAGE="${GHCR_IMAGE_REGISTRY}/projectcontour/contour:v${CONTOUR_VERSION}"
# contour images (from docker.io)
export CONTOUR_ENVOY_IMAGE="${DOCKER_IMAGE_REGISTRY}/envoyproxy/envoy:v${ENVOY_VERSION}"

# cert-manager images (from quay.io), not required if certs are created by another tool
export CERT_MGR_CAINJECTOR_IMAGE="${QUAY_IMAGE_REGISTRY}/jetstack/cert-manager-cainjector:v${CERT_MANAGER_VERSION}"
export CERT_MGR_CONTROLLER_IMAGE="${QUAY_IMAGE_REGISTRY}/jetstack/cert-manager-controller:v${CERT_MANAGER_VERSION}"
export CERT_MGR_WEBHOOK_IMAGE="${QUAY_IMAGE_REGISTRY}/jetstack/cert-manager-webhook:v${CERT_MANAGER_VERSION}"
export CERT_MGR_ACMESOLVER_IMAGE="${QUAY_IMAGE_REGISTRY}/jetstack/cert-manager-acmesolver:v${CERT_MANAGER_VERSION}"


##
## Type specific config
##
case "$K8S_TYPE" in
  "KIND")
	export K8S_CLUSTER_KORIFI_YAML="${scriptpath}/k8s_korifi_cluster_config.yaml"

	# Can't use default ports (80,443) for cf gateway, because kind doesn't support real loadbalancers.
	# Therefore port-forwarding is required (also for api), which is per-service. As api is hardcoded
	# on port 443, the gateway ports need to be on different ports, so using 32080,32443 instead.
	export CF_HTTP_PORT=32080
	export CF_HTTPS_PORT=32443
	;;
  "AKS")
        # Define Service Principal details
	echo "[DBUG] processing AKS vars"
        export AZ_ENV_FILE="${scriptpath:-.}/.env.azure"

        export AZ_SERVICE_PRINCIPAL="SP_korifi"
        export AZ_APP_ID="value-in-env-file"
        export AZ_CLIENT_SECRET="${AZ_CLIENT_SECRET:-}"
        export AZ_TENANT_ID="value-in-env-file"
        # Other Azure variables (need to be entered here or will be asked during runtime)
        export AZ_SUBSCRIPTION_ID="value-in-env-file"
        # shellcheck source=/dev/null disable=SC2090    # ShellCheck can't follow non-constant source, but not needed here
        test -f "$AZ_ENV_FILE" && . "$AZ_ENV_FILE"

	;;
  "UNKNOWN")
	echo "Environment variable 'K8S_TYPE' must be set (KIND, AKS) to specify the type of Kubernetes used"
	echo "Script aborted!"
	return 1
	;;
  *)
        echo "Value '$K8S_TYPE' for environment variable 'K8S_TYPE' is not a valid type! (valid types: KIND, AKS)"
	return 1
        ;;
esac


##
## Defaults for Deployment type depending variables
##
if [[ -z "$LOCAL_IMAGE_REGISTRY_FQDN" ]];then
  # No local image registry is set, so let's use defaults
  echo "[DEBUG ] Using original registries, dynamic deployment for contour"
  # This means:
  # - dynamic deployment for contour
      export DEPLOY_TYPE_CONTOUR=dynamic
      export ENVOY_SVC=envoy-korifi
  # - all images will be pulled from public registries
      # images will be pulled from their respective public registries (e.g. docker.io, ghcr.io, gcr.io, quay.io, registry.k8s.io)"
  # - default clusterbuilder as installed by kpack deployment
      export CLUSTERBUILDER_CREATION="true"
      export CLUSTERBUILDER_NAME=${CLUSTERBUILDER_NAME:-cf-kpack-cluster-builder}
else
  # A local image registry is set, so let's use it!
  echo "[DEBUG] Using local registry '$LOCAL_IMAGE_REGISTRY_FQDN', static deployment for contour"
  # This means:
  # - static deployment for contour
      export DEPLOY_TYPE_CONTOUR=static
      export ENVOY_SVC=envoy
  # - all images will be pulled from the local registry (assuming all images are available, see install_local_image_registry.sh)
      # korifi images will be prepended with $LOCAL_IMAGE_REGISTRY_FQDN just before call helm chart to deploy korifi
      # cert manager and kpack images are not used in install scripts and will be altered when needed in scripts
  # - custom clusterbuilder that uses local images
      export CLUSTERBUILDER_CREATION="false"
      export CLUSTERBUILDER_NAME=${CLUSTERBUILDER_NAME:-custom-cluster-builder}
fi




##
## Required gpg keys
##

## First add GPG keys and repo sources

# Helm
if [[ ! -f "/etc/apt/keyrings/helm.gpg" ]]; then
  curl -fsSL https://baltocdn.com/helm/signing.asc | gpg --dearmor | sudo tee /etc/apt/keyrings/helm.gpg > /dev/null
  echo "deb [signed-by=/etc/apt/keyrings/helm.gpg] https://baltocdn.com/helm/stable/debian all main" | sudo tee /etc/apt/sources.list.d/helm-stable-debian.list
fi

# Cloud Foundry CLI
if [[ ! -f "/etc/apt/keyrings/cloudfoundry.gpg" ]]; then
  curl -fsSL  https://packages.cloudfoundry.org/debian/cli.cloudfoundry.org.key| gpg --dearmor | sudo tee /etc/apt/keyrings/cloudfoundry.gpg > /dev/null
  echo "deb [signed-by=/etc/apt/keyrings/cloudfoundry.gpg] https://packages.cloudfoundry.org/debian stable main" | sudo tee /etc/apt/sources.list.d/cloudfoundry-cli.list
fi

#echo "...done"
